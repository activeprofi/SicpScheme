#lang racket

; Упражнение 1.4.
; Заметим, что наша модель вычислений разрешает существование комбинаций, операторы кото-
; рых — составные выражения. С помощью этого наблюдения опишите, как работает следующая
; процедура:
; (define (a-plus-abs-b a b)
; ((if (> b 0) + -) a b))
;-------------------------------------------------------------------
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))

(= (a-plus-abs-b 1 5) 6)
(= (a-plus-abs-b 1 -5) 6)
;-------------------------------------------------------------------
; Применим процедуру a-plus-abs-b к 2м аргументам 1 и -5
; (a-plus-abs-b 1 -5)
; Так как компилятор использует аппликативный порядок вычислений,
; то первым делом вычислятся выражения для каждого аргумента.
; Для элементарных выражений, которые представляют числа, результатом будет само число.
; 1  =>  1
; -5 => -5
; Подставляем в нашу процедуру
; ((if (> -5 0) + -) 1 -5)
; Имеем составное или сложное выражение (комбинацию).
; Внутри него 3 подвыражения: это особая форма if и 2 числа.
; Найдем результат выражения с особой формой:
; -5 > 0 - ложь, возвращаем оператор - и выражение редуцируется в:
; (когда число положительное, результат if будет оператор +)
; (- 1 -5)
; Рузультат вычислений = 6
;===================================================================